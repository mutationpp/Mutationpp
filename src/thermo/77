/**
 * @file ParticleRRAHO.cpp
 *
 * @brief Implementation of the ParticleRRAHO class.
 */

#include "ParticleRRAHO.h"
#include "Utilities.h"
#include "Constants.h"

#include <cassert>
#include <iostream>
#include <fstream>
#include <string>
#include <iomanip>
#include <cstdlib>

using namespace std;
using namespace Kappa::Utilities;

namespace Kappa {
    namespace Thermodynamics {

//==============================================================================

ParticleRRAHO::ParticleRRAHO(const IO::XmlElement& xml_element)
    : m_hform(0), m_steric(0), m_linearity(0), m_rotational_t(0), m_mass(0),
      m_eform(0)
      // TODO add other variables to initialize!	
{
    // Load information stored in child elements
    IO::XmlElement::const_iterator iter = xml_element.begin();

    for ( ; iter != xml_element.end(); ++iter) {

	if (iter->tag() == "mass") {
            std::string str;
            iter->getAttribute("units", str, "kg");
            m_mass = Units(str).convertToBase(
            atof(iter->text().c_str()));
            //cout << " Particle's mass is: " << m_mass << endl;          
        }
	else if (iter->tag() == "diameter") {
            m_diameter = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's diameter is: " << m_diameter << endl;
        }
        else if (iter->tag() == "LJeps") {
            m_eps_LJ = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's eps_LJ is: " << m_eps_LJ << endl;
        }
        else if (iter->tag() == "formation_energy") {
            m_formation_energy = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's formation energy is: " << m_formation_energy << endl;
        }
	else if (iter->tag() == "formation_enthalpy") {
            m_hform = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's formation enthalpy is: " << m_hform << endl;
        }
	// Add in the database file all temperatures
	// or computed vibrational energies later
        //else if (iter->tag() == "vibrational_temperatures") {
        //    std::vector<std::string> tokens;
        //    String::tokenize(iter->text(), tokens, " ,\t\n\r\f\v");
        //    
        //    std::vector<std::string>::const_iterator t_iter = tokens.begin();
        //    for ( ; t_iter != tokens.end(); ++t_iter)
        //        m_vibrational_energies.push_back(atof(t_iter->c_str()));

        //    for (int i=0; i<m_vibrational_energies.size(); ++i)
        //        cout << " Particle's vibrational temperatures are: " 
	//	     << m_vibrational_energies.at(i) << endl;
        //}
	else if (iter->tag() == "ionization_potential") {
             m_ionization_potential = atof(String::trim(iter->text()).c_str());
             //cout << " Particle's ionization potential is: " 
	     //	  << m_ionization_potential << endl;
        }
        else if (iter->tag() == "inertia_moment") {
            m_inertia_moment = atof(String::trim(iter->text()).c_str());
	    //cout << " Particle's moment of inertia is: " << m_inertia_moment << endl;
        }
	// Not present in database
        else if (iter->tag() == "symmetry_factor") {
            m_symmetry_factor = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's symmetry factor is: " << m_symmetry_factor << endl;
        }
        else if (iter->tag() == "parker_Zeta_inf") {
            m_parker_zeta_inf = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's Parker zeta inf is: " << m_parker_zeta_inf << endl;
        }
	// Not present in database
        else if (iter->tag() == "charge") {
            m_charge = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's charge is: " << m_charge << endl;
        }
        else if (iter->tag() == "reduced_oscillator_mass") {
            m_reduced_oscillator_mass = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's reduced oscillator mass is: " << m_reduced_oscillator_mass << endl;
        }
        else if (iter->tag() == "internuclear_distance") {
            m_r_e = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's internuclear distance is: " << m_r_e << endl;
        }
        else if (iter->tag() == "mA_mAB") {
            m_mA_mAB_ratio = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's mA/mAB is: " << m_mA_mAB_ratio << endl;
        }
	else if (iter->tag() == "mB_mAB") {
            m_mB_mAB_ratio = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's mB/mAB is: " << m_mB_mAB_ratio << endl;
        }
	// Not present in database
        else if (iter->tag() == "molar_mass") {
            m_mw = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's molar weight is: " << m_mw << endl;
        }
	// Not present in database
        else if (iter->tag() == "type") {
            m_type = String::toLowerCase(String::trim(iter->text()));
            //cout << " Particle's type is: " << m_type << endl;
        }
	// Symmetry factor (TODO clean up)
        else if (iter->tag() == "steric_factor") {
            m_steric = atoi(String::trim(iter->text()).c_str());
            //cout << " Particle's steric factor is: " << m_steric << endl;
        }
        else if (iter->tag() == "linear") {
            std::string yesno = String::trim(iter->text());
            if (yesno == "yes")
                m_linearity = 2;
            else if (yesno == "no")
                m_linearity = 3;
            else {
                iter->parseError(
                    "Values for linear can only be \"yes\" or \"no\"!");
            }
            //cout << "is Particle linear: " << yesno << " " << m_linearity << endl;
        }
        else if (iter->tag() == "rotational_temperature") {
            m_rotational_t = atof(String::trim(iter->text()).c_str());
            //cout << " Particle's rotational temperature is: " << m_rotational_t << endl;
        }
        else if (iter->tag() == "electronic_levels") {
            IO::XmlElement::const_iterator level_iter = iter->begin();
            
            int    degeneracy;
            double temperature;
	    double elec_energy;
	    double diss_energy;

	    int e = 0; // electronic level index

	    // rotational stuff ...
	    //std::vector<double> ev_level_rot_energies;
    	    //std::vector<int> e_level_rot_amt;
     	    //std::vector<std::vector<double>> e_level_rot_energies;
            
	    // Loop over electronic levels
	    //////////////////////////////
            for ( ; level_iter != iter->end(); ++level_iter, e++) {

	        //cout << " Electronic level: " << e << "\n";    

                if (level_iter->tag() == "level") {

                    level_iter->getAttribute("degeneracy", degeneracy);
		    level_iter->getAttribute("elec_energy", elec_energy);
		    level_iter->getAttribute("diss_energy", diss_energy);

                    m_we.push_back(level_iter->getAttribute("we", we));
                    m_wexe.push_back(level_iter->getAttribute("wexe", wexe));
                    m_weye.push_back(level_iter->getAttribute("weye", weye));
                    m_weze.push_back(level_iter->getAttribute("weze", weze));
                    m_be.push_back(level_iter->getAttribute("Be", be));
                    m_ae.push_back(level_iter->getAttribute("Ae", ae));
                    m_de.push_back(level_iter->getAttribute("De", de));

                    m_electronic_energies.push_back(std::make_pair(degeneracy,
		        elec_energy));

		    // Electronic energy
		    m_electronical_energies.push_back(elec_energy);
                    //cout << e << " " << m_electronical_energies.at(e) << endl;

		    // Dissociation energy
		    m_dissociation_energies.push_back(diss_energy);
                    //cout << e << " " << m_dissociation_energies.at(e) << endl;

		    m_vibrational_temperatures.push_back(HP * C0 * m_we.at(e) / KB);
                    //cout << " Vibrational characteristic temperature ["<<e<<"] = " 
		    //     << m_vibrational_temperatures.at(e) << endl;

                    //cout << e << " " << m_we.at(e) << endl;
                    //cout << e << " " << m_wexe.at(e) << endl;
                    //cout << e << " " << m_weye.at(e) << endl;
                    //cout << e << " " << m_weze.at(e) << endl;

		    // Vibrational energy
		    /////////////////////
	            double morse = 0.0;	
      	            //int lvib = 0; // vibrational levels
      	            int v = 0; // vibrational level index

		    vib_energy.push_back(vector<double>());
	            while (morse < (m_dissociation_energies.at(e) - 
			            m_electronical_energies.at(e))) 
	            {
 	                // Morse potential, Eq. 1.3, Nagnibeda & Kustova 2009.
                        morse = HP * C0 * (m_we.at(e) * (v + 0.5) - 
 	                    m_wexe.at(e) * (v + 0.5) * (v + 0.5) +
 	                    m_weye.at(e) * (v + 0.5) * (v + 0.5) * (v + 0.5) +
 	                    m_weze.at(e) * (v + 0.5) * (v + 0.5) * (v + 0.5) * (v + 0.5));
 	
			//cout << " morse["<<v<<"] = " << morse << endl;
   	                m_vibrational_energies.push_back(morse);
   	                vib_energy[e].push_back(morse);
 	                v++;
 	            }
                    
		    //cout << " vib_energy " << vib_energy.size() << endl;
		    //cout << " vib_energy[e] " << vib_energy[e].size() << endl;

		    // Vibrational levels for the electronic level e
		    //lvib = v; //v - 1;
		    m_partial_vibrational_energies.push_back(v);
		    m_vibrational_levels.push_back(v);
		    //cout << " Vib. levels " << v << " " 
		    //	 << m_partial_vibrational_energies.size() << " "  
		    //   << m_partial_vibrational_energies.at(e) << endl;

		    // Rotational energy
		    ////////////////////
	            double rot = 0.0;
      	            //int lrot = 0; // rotational levels
      	            int r = 0; // rotational level index

		    // Rotational levels for the electronic level e
		    // For RR the rotational level does not depend 
		    // on the vibrational state
	            while (rot < (m_dissociation_energies.at(e) - 
			          m_electronical_energies.at(e)))
	            {                                                          
		        rot = HP * C0 * m_be.at(e) * r * (r+1);
		        //cout << " ROT["<<r<<"] = "<< rot << endl; // 198
 	                r++;
 	            }

		    // Rotational levels for the electronic level e
		    //lrot = r; //r - 1;
		    //cout << " Rot. levels " << lrot << endl; // 198
		    m_partial_rotational_energies.push_back(r);
		    m_rotational_levels.push_back(r);
	            //cout << m_rotational_levels.size() << endl;
	            //cout << m_rotational_levels[0] << endl;
		    //cout << " Rot. levels " << r << " " 
		    //     << m_partial_rotational_energies.at(e) << endl;
                      
		    // For each vibrational level, assign the rotational
		    // energy of electronic level e
		    rot_energy.push_back(vector<vector<double>>());
		    for (v=0; v!=m_vibrational_levels.at(e); ++v) { 
			rot_energy[e].push_back(vector<double>());
		        for (r=0; r!=m_rotational_levels.at(e); ++r) { 
		            rot = HP * C0 * (m_be.at(e) * r * (r+1)); 

		            rot_energy[e][v].push_back(rot);
		            m_rotational_energies.push_back(rot);
		        }
		    }

		    //cout << "Rot. En. " << rot_energy.size() << endl;
		    //cout << "Rot. En. [e] " << rot_energy[e].size() << endl;
		    //cout << "Rot. En. [e][v] " << rot_energy[e][v-1].size() << endl;

                    //cout << " Number of vibrational levels: " 
		    //	 << m_vibrational_energies.size() << endl;
            		
		    //cout << " Particle's vibrational energy at electron level " 
		    //     << e << " are: " << "\n";
            	    //     for (int i=0; i<m_vibrational_energies.size(); ++i)
                    //         cout << i << " " 
		    //    	  << m_vibrational_energies.at(i) << endl;

                    //cout << " Number of rotational levels: " 
		    //     //<< rot_energy.size() << endl;  
		    //     << m_rotational_energies.size() << endl;  
		}
		//e++; // increment of the electronic level index
	    }

	    
            //for (int e=0; e<m_electronical_energies.size(); ++e) {
	    //    cout << " e = " << e << endl;
	    //    for (int v=0; v<vib_energy.at(e).size(); ++v) {
	    //        cout << " v = " << v << endl;
	    //        for (int r=0; r<rot_energy.at(e).at(v).size(); ++r) {
	    //            cout << " r = " << r << " " <<
	    //    	rot_energy.at(e).at(v).at(r) << endl;
	    //    	//rot_energy[e][v][r] << endl;
	    //        }
	    //    }
	    //}


            //cout << " Particle's dissociation energies are: " << "\n";
            //for (int i=0; i<m_dissociation_energies.size(); ++i)
            //    cout << m_dissociation_energies.at(i) << endl;
	     
            //cout << " Particle's electronical energies are: " << "\n";
            //for (int i=0; i<m_electronical_energies.size(); ++i)
            //    cout << m_electronical_energies.at(i) << endl;
	    
	}
    }
}

//==============================================================================

ParticleRRAHO::ParticleRRAHO(const ParticleRRAHO& rraho, const size_t level)
    : m_hform(rraho.m_hform + rraho.electronicEnergy(level).second),
      m_steric(rraho.m_steric),
      m_linearity(rraho.m_linearity),
      m_rotational_t(rraho.m_rotational_t),
      m_electronic_energies(1, rraho.electronicEnergy(level)),
      m_vibrational_energies(rraho.m_vibrational_energies),
      // LC
      m_rotational_energies(rraho.m_rotational_energies)
{
    // Make sure the level used is actually present in the given RRAHO parameters
    assert(level < rraho.nElectronicLevels());
}

//==============================================================================

} // namespace Thermodynamics
} // namespace Kappa
